# Safety of MongoDB Logless Reconfig Protocol

The standard MongoDB replication protocol, without any reconfiguration, is specified by the [`MongoStaticRaft`](../MongoStaticRaft.tla) specification. This protocol is based on the standard Raft protocol and satisfies the same fundamental safety properties. The main safety property of Raft is the *state machine safety* property, which ensures that, if a log entry has been marked committed at a certain index, no conflicting log entry will ever be marked committed at the same index. We define this safety property as a temporal property `StateMachineSafety`. The theorem [`MongoStaticRaftSafety`](../MongoStaticRaft.tla#L168) should hold. It follows from the safety proof in the original Raft disseration. 

The new, logless MongoDB reconfiguration protocol, which is specified in [`MongoRaftReconfig`](../MongoRaftReconfig.tla), extends `MongoStaticRaft` to allow for reconfiguration changes. Ultimately, our goal is to verify that `MongoRaftReconfig` satisfies the same safety property as the static protocol. That is, we want to verify [`MongoRaftReconfigSafety`](../MongoRaftReconfig.tla#L103). At a high level, the `MongoRaftReconfig` protocol is a composition of two conceptually distinct Raft state machines. We refer to these as the *oplog state machine (OSM)* and the *config state machine (CSM)*. The former is responsible for managing user data and the latter responsible for managing configuration state of the replica set. Both state machines run their protocols independently, but synchronize on some actions, and share some state. The CSM runs a protocol described by the specification [`MongoLoglessDynamicRaft`](../MongoLoglessDynamicRaft.tla), which is a variant of the static protocol that allows for operations of the state machine to change the definition of a quorum. The OSM runs the `MongoStaticRaft` protocol. `MongoRaftReconfig` is a composition of these two protocols, and each sub protocol (the OSM and CSM) operates over a subset of [common, global variables](../MongoRaftReconfig.tla#L16-L23). The protocols do share some state, related to terms and elections, so the composition is not fully asynchronous. They synchronize on the election action i.e. both protocol must take an election step jointly. This composition is expressed formally in the [specification](../MongoRaftReconfig.tla#L75-L94) of `MongoRaftReconfig`.

To summarize the above protocols:
- `MongoStaticRaft`: The standard, static MongoDB Raft replication protocol where configurations are fixed. Safety of this protocol has already been proven.
- `MongoLoglessDynamicRaft`: An extended form of the static  protocol where state machine operations are allowed to change the quorum definition on different nodes.
- `MongoRaftReconfig`: the complete, new MongoDB replication protocol which allows for dynamic reconfiguration. It is built as a composition of `MongoStaticRaft`, used by the OSM, and `MongoLoglessDynamicRaft`, used by the CSM. Establishing safety of this protocol is our main goal.

## Verifying *MongoLoglessDynamicRaft*

In order to verify that `MongoRaftReconfig` behaves safely , we ultimately need to ensure that the OSM, which we consider as the "externally visible" state machine, 
operates safely when composed with the CSM. In order to do this, however, we first need to ensure that the CSM behaves correctly i.e. we need to establish that `MongoLoglessDynamicRaft` is safe. `MongoLoglessDynamicRaft` is based on the `MongoStaticRaft` protocol, but it breaks some key assumptions necessary for ensuring safety of the static protocol. Thus, it is not a direct implementation of the `MongoStaticRaft` protocol, so it does not inherit its safety properties directly. Specifically, the static protocol assumes that every node starts out with a common, fixed configuration (a subset of server nodes) that never changes. The dynamic protocol, however, allows the configuration stored on different nodes to change over time. Additionally, `MongoLoglessDynamicRaft` does not store an explicit log of operations i.e. it optimizes them away. To make reasoning more straightforward, we define a version of this protocol that keeps an explicit log, which we specify as `MongoDynamicRaft`. For reasoning we consider the `MongoDynamicRaft` protocol, and eventually show that `MongoLoglessDynamicRaft` is a refinement of `MongoDynamicRaft`.

Our main goal is to show that `MongoDynamicRaft` satisfies the `StateMachineSafety` property. To do this, we start by looking at how this protocol relates to the static version of the protocol. `MongoStaticRaft` relies on an assumption, which we refer to as `StrictQuorumCondition`, that any quorums used by different nodes will always overlap in at least one node. The set of quorums that can be used by a node is based on its current configuration. Since the configuration on all nodes is the same and never modified in the static protocol, a simple majority quorum system satisfies this condition. `MongoDynamicRaft` plainly violates this assumption, since the configurations on nodes may change in arbitrary ways. We can examine, however, why quorums are necessary in the static protocol and try to generalize these requirements to the dynamic protocol. In `MongoStaticRaft` quorums are used in *elections* and *commitment.* That is, a candidate for leader must garner votes from a a quorum of nodes, and a current leader must replicate a write to a quorum of nodes before that write becomes committed. The first condition ensures that newer candidates always intersect with some node that participated in a past election, to prevent two leaders being elected in the same term. The second condition ensures that newer candidates always overlap with some node that contains a committed entry, so that they contain the entry in their log upon becoming leader. So, these conditions do not depend strictly on all quorums overlapping, but rather, that when a node is elected or commits a write, future candidates can "know" about this event. 


Based on this, we can consider a weaker, more general condition, which we call `WeakQuorumCondition`, that is sufficient to guarantee safety. This condition is derived from the fact that quorum overlap in standard Raft, for both voting and commitment, is not in and of itself necessary, but rather, is used as a mechanism to ensure that future candidates always contact at least some node that participated in a past election or log entry commitment. In order to consider protocols that can satisfy `WeakQuorumCondition` without necessarily satisfying the stricter condition, we also define a more general protocol, which removes all assumptions about what quorums can be used by separate nodes. This protocol is specified as [`MongoWeakRaft`](../MongoWeakRaft.tla), and includes a formal definition of the [`StrictQuorumCondition`](../MongoWeakRaft.tla#L180-L187) and [`WeakQuorumCondition`](../MongoWeakRaft.tla#L189-L200) properties, which are both specified as state predicates.

We claim that any protocol that implements `MongoWeakRaft` and satisfies `WeakQuorumCondition` satisfies `StateMachineSafety` (in addition to the other core safety properties of static Raft). We state this as the theorem [`WeakQuorumSafety`](../MongoWeakRaft.tla#L241). We can then use this weaker safety condition to help us prove the correctness of `MongoDynamicRaft`. First, we want to show that `MongoDynamicRaft` refines `MongoWeakRaft`, which should be a straightforward step since the latter is a very general protocol. Second, we want to show that `MongoDynamicRaft` satisfies the `WeakQuorumCondition`. We can prove this inductively. If we have already established the refinement step, and we assume that `WeakQuorumCondition` held in all previous states up to and including the current one (our induction hypothesis), then we should be able to conclude that in the current state, `MongoDynamicRaft` satisfies all safety properties of static Raft. This allows us to make use of the properties already established about a static Raft log to help prove the correctness of the dynamic protocol.

Note that this technique is necessary to avoid re-proving the correctness of `MongoDynamicRaft` from scratch due to an inherent circularity in reasoning that needs to be avoided. For example, in `MongoStaticRaft`, there are some auxiliary safety properties (lemmas), like `ElectionSafety`, that hold independently of other properties, and that do not depend on properties of the Raft log. In the dynamic protocol, however, properties like `ElectionSafety` depend on the safety of the Raft log, but the safety of the Raft log itself depends on the `ElectionSafety` property. Said another way, in order to prove the overall `StateMachineSafety` property, we need to assume that `ElectionSafety` holds, but to prove `ElectionSafety` holds, we need to assume that `StateMachineSafety` holds. So, we cannot plainly assume that `ElectionSafety` holds when trying to prove further properties about the `MongoDynamicRaft` protocol. To break this circularity, we use induction, and assume that the protocol satisfied all required safety properties in the current step, and show that it maintains them in the next step. This reasoning is valid since we know that the `MongoDynamicRaft` protocol satisfies the safety properties in the initial state. 

<!-- So, now we aim to show that

```tla
MongoLoglessDynamicRaft!Spec => MongoWeakRaft!Spec        (refinement)
MongoLoglessDynamicRaft!Spec => WeakQuorumCondition       (invariance)
```
which, due to `WeakQuorumSafety`, is sufficient to imply

```tla
MongoLoglessDynamicRaft!Spec => Safety
```

which establishes our goal. -->

<!-- Refinement: We can show that `MongoLoglessDynamicRaft!Spec => MongoWeakRaft!Spec`, through a series of stepwise refinements between `MongoLoglessDynamicRaft` and `MongoWeakRaft` (TODO: Elaborate on these refinement steps). 

Invariance: We can show that `WeakQuorumCondition` is upheld by `MongoLoglessDynamicRaft` via an inductive invariance proof, which also utilizes the theorem `MongoStaticRaftSafety` theorem.  -->


## The Oplog State Machine

Once we have shown that the CSM is safe, we can then show that the OSM behaves correctly when composed with the CSM. Since elections are shared between the OSM and CSM, we already know that the election related condition of `WeakQuorumCondition` holds for the `MongoRaftReconfig` spec, but we will need to show the log related condition holds. Since we know that the CSM operates as a correct Raft state machine, and we know that a committed log entry must be committed in a current config before a reconfig is allowed, we should be able to show this fairly easily, by reasoning over the history of configs in the CSM.

### Protocols Overview and Refinements

![](refinements.png)

- `MongoWeakRaft` - A very general, weak protocol that places no restrictions on quorums used by nodes.
- `MongoStaticRaft` - The existing replication protocol used by MongoDB that is based on Raft. It does not allow for dynamic reconfiguration and it satisfies all the same safety properties as standard Raft, as described in the Raft dissertation. It implements `MongoWeakRaft` and should satisfy `StrictQuorumCondition`.
- `MongoLockstepWeakRaft` - Weak quorum protocol but requires a log entry be committed in a node's own quorum before writing a new entry.
- `MongoDynamicRaft` - A variant of `MongoStaticRaft` that allows for state machine operations to modify the configuration. This protocol keeps an explicit log and is closest to the Raft dissertation reconfig algorithm.
- `MongoLoglessDynamicRaft` - A variant of `MongoDynamicRaft` that optimizes away the log, and only stores the latest config on each node. The goal is to have this refine `MongoDynamicRaft`.
- `MongoRaftReconfig` - The new MongoDB protocol that allows for dynamic reconfiguration. Behaves as a composition of `MongoLoglessDynamicRaft` which runs the CSM and `MongoStaticRaft` which runs the OSM.